---
title: "Beyond multivariate applications: Quarto for reproducible interactive documents"
author: "Sean van der Merwe, JohanÃ© Nienkemper-Swanepoel, Raeesa Ganey"
format: 
  revealjs: 
    theme: [default, MDAG1.scss]
    logo: MDAGlogo.png
    footer: "2025/11/25 - MDAG"
    slide-number: "c/t"
    chalkboard: true
    margin: 0.05
    parallax-background-image: "stats_background.jpg"
    parallax-background-size: "2304px 1536px"
    parallax-background-vertical: 80
execute:
  echo: false
---


# Introduction

> Welcome to our workshop!

::: {.callout-note}
# You can follow the slides at

seanvdm.co.za/mdag2025
:::

On the last slide of Part 1 you will find a link to all the resources for the day.

```{r}
#| warning: false
#| message: false
#| results: hide
options(scipen = 12)
library(knitr)
opts_chunk$set(fig.ext = 'svg', dev = 'svg', fig.align = 'center')
wrap_strings <- function(vector_of_strings, width){ as.character( sapply( vector_of_strings, \(x) { paste( strwrap(x, width=width), collapse="\n")}))}

MDAGcolours <- c(SASAblue = "#3B4569", lighter = "#5968A2", Main = "#1E2327", O2 = "#e6edf3", DarkBlue = "#0F204B", DarkRed = "#A71930", Black="#000000FF", O1 = "#848d97")
library(tidyverse)

library(plotly)
fig_w <- 960
fig_h <- 400

plotly_table_MDAG <- function(datafrm, height = "100%", width = "100%", 
              colors=MDAGcolours, useRowNames = FALSE, rowNamesHeading = " ") {
  datafrm <- as.data.frame(datafrm)
  nms <- names(datafrm)
  if (useRowNames) {
    datafrm <- data.frame(row.names(datafrm), datafrm, row.names = NULL)
    nms <- c(rowNamesHeading, nms)
    names(datafrm) <- nms
  }
  k <- ncol(datafrm)
  algn <- rep('center', k)
  cell_values <- rbind(t(as.matrix(unname(datafrm))))
  fig <- plot_ly(
  type = 'table',
  height = height,
  width = width,
  header = list(
    values = nms,
    align = algn,
    line = list(width = 1, color = colors[2]),
    fill = list(color = colors[1]),
    font = list(family = "Arial", size = 14, color = "#FFFFFFFF")
  ),
  cells = list(
    values = cell_values,
    align = algn,
    line = list(color = colors[2], width = 1),
    fill = list(color = list(rep(c("#FFFFFFFF", colors[4]), ceiling(length(cell_values)/2)))),
    font = list(family = "Arial", size = 12, color = colors[3])
  ))
fig
}
plotly_colours <- MDAGcolours |> unname()
```

## Outline

Hit refresh (F5 or Ctrl+r) if nothing is showing.

```{r}
#| fig-height: 6.6
library(visNetwork)
outline_network <- \() {
  cols <- rev(viridisLite::turbo(9))[-1]
  outline_node_lables <- c('Sean', 'Sean', 'Sean &\nJohanÃ©', 'JohanÃ©', 'Raeesa', 
                           'Part 1', 'Possibilities', 'Creativity', 'Passion', 
                           'Part 2', 'Tools', 'Principles', 'Technicalities', 
                           'Part 3', 'Hands on', 'Multivariate\nData', 'Draw plots\nyourself',
                           'Part 4', 'GitHub', 'Make\nwebsite', 'Customize')
  n_outline_nodes <- length(outline_node_lables)
  nodes <- data.frame(id = 1:n_outline_nodes, 
                      label = outline_node_lables,
                      shape = c(rep("box", 5), rep("ellipse", 16)),
                      color = cols[c(1, 1, 2, 2, 3, rep(4:7, e=4))],
                      x = c(rep(-1,4), -3, rep(0:3, t=4))*440, 
                      y = c(seq(-1,2), 0.5, rep(seq(-1,2), e=4))*200, 
                      physics = rep(c(FALSE, TRUE), c(4, n_outline_nodes-4)),
                      font = "32px"
                      )
  e_seq <- c(6, 10, 14, 18)
  edges <- data.frame(from = c(rep(5,4), 1:3, 1:4, e_seq, e_seq+1, e_seq+2),
                      to   = c(1:4,  2:4, e_seq, e_seq+1, e_seq+2, e_seq+3),
                      arrows = "to", 
                      length = c(500, 300, 300, 500, rep(280, 19))
                      )
visNetwork(nodes, edges, physics = TRUE)
}
library(htmlwidgets)
library(widgetframe)
frameWidget(outline_network())
```

# Part 1

Think about your own situations. With each example, think about where you might apply these ideas in your own

-   Research presentations
-   Teaching presentations
-   Resources you make available to students

# Interactive data exploration

## Example: survey exploration


```{r}
boxplot_plotly <- \() {
  spending <- expand.grid(Gender = c("Female", "Male"), 
                          City = c('Bloemfontein', 'East London', 'Durban'), 
                          Replicate = 1:20)
  set.seed(12345)
  spending$Weekly_Spending <- round(
    (rgamma(nrow(spending), 10 + (spending$Gender == "Male") + 
              (spending$City == "Durban")*3, 5))*1000, 0)
  spending |> 
    plot_ly(x = ~City, y = ~Weekly_Spending, color = ~Gender, type = 'box', 
            colors = c("#A71930", "#0F204B"), width = fig_w, height = fig_h*1.2) |>
    layout(boxmode = "group")
}
boxplot_plotly()
```


## What about time series?

We could simulate a pair of $VARIMA_2(1,1,1)-tGARCH(1,1)$ financial time series like so:

```{r}
varima_plotly <- \() {
  set.seed(121)
  n <- 120
  e <- mvtnorm::rmvt(n, sigma = c(1, 0.5, 0.5, 1) |> matrix(2), df = 4)
  x1 <- x2 <- v1 <- v2 <- rep(1, n)
  for (i in 2:n) {
    v1[i] <- 0.5 + 0.2*e[i-1, 1]^2 + 0.3*v1[i-1]
    v2[i] <- 0.5 + 0.2*e[i-1, 2]^2 + 0.3*v2[i-1]
    e[i,] <- e[i,] * sqrt(c(v1[i], v2[i]))
    x1[i] <- 0.1 + 0.3*x1[i-1] + 0.3*e[i-1, 1] + e[i, 1]
    x2[i] <- 0.12 + 0.35*x2[i-1] + 0.2*e[i-1, 2] + e[i, 2]
  }
  d <- data.frame(
    Month = seq_len(n-20), 
    ABC = cumsum(x1[21:n]/60) |> exp() + 30,
    DEF = cumsum(x2[21:n]/50) |> exp() + 29.5
  )
  d |> plot_ly(width = fig_w, height = fig_h) |>
    add_trace(x = ~Month, y = ~ABC, type = 'scatter', mode = 'lines', name = "ABC") |>
    add_trace(x = ~Month, y = ~DEF, type = 'scatter', mode = 'lines', name = "DEF") |>
    layout(yaxis = list(title = "Price"))
}
varima_plotly()
```


## Or you can just explore data directly

The ACTG 315 dataset, available in the *ushr* **R** package, includes longitudinal measurements of HIV viral load (log$_{10}$ RNA copies/mL) over time. It features data on 46 patients, with the longest measurement recorded on Day 196 after baseline (Day 0). 

## Data set {.smaller}

```{css}
table.dataTable tbody td {
  font-size: 16px;
  padding: 6px 10px;
}
```

```{r}
actg315 <- ushr::actg315raw
display_data <- actg315 |> select(-Patid)
display_data$PatientID <- actg315$Patid |> factor()
library(DT)
datatable(display_data, rownames = FALSE, filter = "top", 
          options = list(pageLength = 10, dom = "tp"))
```

# Interactive model fits for conveying research results

## Exploring simulation study results {.scrollable}

When you want to know whether two population means are different based on independent samples, is it better to 

1.  do a F test for differing variances followed by a *t*-test assuming equal/unequal variances based on the previous result, or
1.  do a unequal variances t-test always?

Let's simulate a few scenarios:

::: {.incremental}
1.  Equal means, equal variances
1.  Equal means, different variances (1 vs 2)
1.  Equal variances, different means (0 vs 1)
1.  Unequal variances, different means
:::

```{r}
alpha <- 0.05
produce_simulation_study <- \() {
  n_per_sce <- 10000
  spl_sizes <- seq(10, 100, 5)
  base_samples <- spl_sizes |> lapply(\(spl_size) {
    list(pop1 = rnorm(spl_size*n_per_sce) |> matrix(n_per_sce),
         pop2 = rnorm(spl_size*n_per_sce) |> matrix(n_per_sce))
  }) |> setNames(spl_sizes)
  approach1 <- \(x, y) {
    p_var <- var.test(x, y)$p.value
    (t.test(x, y, var.equal = p_var > alpha)$p.value <= alpha)
  }
  approach2 <- \(x, y) {(t.test(x, y)$p.value <= alpha)}
  framework <- expand.grid(Approach = paste("Approach", 1:2), 
                           Scenario = paste("Scenario", 1:4))
  if (!file.exists("SimStudyResults.rds")) {
    final_power_df <- seq_along(spl_sizes) |> lapply(\(j) {
      powers <- seq_len(n_per_sce) |> sapply(\(i) {
        x <- base_samples[[j]]$pop1[i,]
        y <- base_samples[[j]]$pop2[i,]
        c(approach1(x, y), approach2(x, y), 
          approach1(x, y*2), approach2(x, y*2), 
          approach1(x, y+1), approach2(x, y+1), 
          approach1(x, y*2+1), approach2(x, y*2+1))
      }) |> rowMeans()
      data.frame(framework, Sample_Size = spl_sizes[j], Power = powers)
    }) |> bind_rows()
    final_power_df |> saveRDS("SimStudyResults.rds")
  } else {
    final_power_df <- readRDS("SimStudyResults.rds")
  }
final_power_df |> ggplot(aes(x = Sample_Size, y = Power, 
                             colour = Approach, linetype = Approach)) + 
  facet_wrap(~Scenario, scales = "free") + ylim(c(0,1)) + 
  geom_line() + geom_hline(yintercept = alpha) + theme_bw()
}
```

We calculate the power when testing at $\alpha =$ `r alpha` and compare the approaches under each scenario.

**Simulation study results**

Zoom in to see the 'difference'.

```{r}
produce_simulation_study() |> ggplotly(width = fig_w, height = fig_h)
```

## Shower thought for the day {.scrollable}

> When is it better to use a table and when is it better to use a plot to present results?


::: {.fragment .fade-up fragment-index=5}

-   Do you have variables with many levels, particularly continuous or ordinal variables?
    -   Do you have 5 sample sizes or 50 threshold choices?
    -   What about variable hyperparameters?
    
::: {.fragment .highlight-green fragment-index=6}

-   A plot better conveys information that changes gradually
    -   allowing the reader to see patterns in the bigger picture
    
:::

:::


::: {.fragment .fade-left fragment-index=3}

-   Do you have a bunch of factors with few levels, particularly binary or trinary factors?

::: {.fragment .highlight-red fragment-index=4}

-   A table better accommodates such cases because there are only so many factors you can effectively show on a plot
    -   Once you've gone through colour, shape/linetype, size, facet grid or lattice, then the rest becomes noise
    
:::

:::

::: {.fragment .fade-down fragment-index=1}

-   Does someone need to process your results further?
-   Are there so many factors and statistics that it is difficult to fit on a page?

::: {.fragment .highlight-blue fragment-index=2}

-   Output big tables to a neat spreadsheet and upload it publicly (*e.g. GitHub or Figshare*)

:::

:::

## Three continuous, 1 nominal

```{r}
create_predictions_by_age_3d_plotly <- \() {
  predictions_by_age <- readRDS("predictions_by_age_jointmodel.rds")
  Ages <- seq(40,70)
  KUMparsims <- "KUMJointParameterSims.rds" |> readRDS()
  KM_plot_data <- KUMparsims$KMCurve |> mutate(
    Treatment = Treatment |> str_remove("^.*="),
    Time = Time/30
  )
  treatment_plot_lines <- unique(KM_plot_data$Treatment)
  gap <- 0.02
  endpoint <- 12
  time_seq <- seq(0, endpoint, gap)
  
  est1 <- predictions_by_age |> sapply(\(d) {
    d$Estimate[d$Treatment == treatment_plot_lines[1]]}
    ) |> t()
  est1l <- predictions_by_age |> sapply(\(d) {
    d$Cred_Lower[d$Treatment == treatment_plot_lines[1]]}
    ) |> t()
  est1u <- predictions_by_age |> sapply(\(d) {
    d$Cred_Upper[d$Treatment == treatment_plot_lines[1]]}
    ) |> t()
  est2 <- predictions_by_age |> sapply(\(d) {
    d$Estimate[d$Treatment == treatment_plot_lines[2]]}
    ) |> t()
  est2l <- predictions_by_age |> sapply(\(d) {
    d$Cred_Lower[d$Treatment == treatment_plot_lines[2]]}
    ) |> t()
  est2u <- predictions_by_age |> sapply(\(d) {
    d$Cred_Upper[d$Treatment == treatment_plot_lines[2]]}
    ) |> t()
  
  m <- 0.76
  plot_ly(x = time_seq, y = Ages, z = est1, type = 'surface', 
          width = fig_w*0.9, height = fig_h*1.5, colorscale = "Blues", opacity = 1, 
          name = treatment_plot_lines[1], cmin = m, cmax = 1, 
          colorbar = list(title = list(text = treatment_plot_lines[1]),
                          nticks = 8)) |> 
    layout(scene = list(
      xaxis = list(title = "Month", range = c(0, 12)),
      yaxis = list(title = "Age", range = c(40,70)),
      zaxis = list(title = "Adherence", range = c(m,1))
    )) |>
    add_surface(z = est1l, colorscale = "Blues", showscale = FALSE, 
                opacity = 0.3, name = treatment_plot_lines[1], 
                cmin = m, cmax = 1) |> 
    add_surface(z = est1u, colorscale = "Blues", showscale = FALSE, 
                opacity = 0.3, name = treatment_plot_lines[1], 
                cmin = m, cmax = 1) |> 
    add_surface(z = est2, colorscale = "Reds", opacity = 1, 
                cmin = m, cmax = 1, reversescale = TRUE,
                name = treatment_plot_lines[2],
                colorbar = list(title = list(text = treatment_plot_lines[2]))) |>  
    add_surface(z = est2l, colorscale = "Reds", showscale = FALSE, 
                opacity = 0.3, name = treatment_plot_lines[2], 
                cmin = m, cmax = 1, reversescale = TRUE) |> 
    add_surface(z = est2u, colorscale = "Reds", showscale = FALSE, 
                opacity = 0.3, name = treatment_plot_lines[2], 
                cmin = m, cmax = 1, reversescale = TRUE)
}
create_predictions_by_age_3d_plotly()
```

## Plotting data on the model

One of the best ways to evaluate the fit of a model is to plot the model and show the data over it. Here we are analysing a reduction in pollution at a dam:

```{r}
#| warning: false
crazyts_plot <- \() {
crazyts <- readRDS('crazyts.rds')
pnttype <- rep('Observed', nrow(crazyts$m_data))
pnttype[crazyts$m_data$IsLeftCensored | crazyts$m_data$IsRightCensored] <- 'Censored'
pnttype <- factor(pnttype, levels = rev(unique(pnttype)))
cols <- viridisLite::magma(6)[c(2,4)] |> setNames(NULL)
plot_ly(width = fig_w, height = fig_h) |> add_trace(x = ~Date, y = ~LogValue, 
            color = ~Location, colors = cols, 
            type = 'scatter', mode = 'markers', 
            symbol = ~pnttype,
            data = crazyts$m_data) |>
  add_trace(x = ~Date, y= ~Value, 
            color = ~Location, linetype = ~Line,
            type = 'scatter', mode = 'lines', 
            colors = cols, data = crazyts$mu_data,
            visible = "legendonly")
}
crazyts_plot()
```

## Curvy data


```{r}
curves_plot_Gompertz <- \() {
plt <- readRDS('presentation plot curves1.rds')
plt$d$Putrescine <- plt$d$H04
plt$d |> plot_ly(x = ~Hour, y= ~Putrescine, width = fig_w*0.8, height = fig_h*1.2, 
                 color = ~StrainDescription, colors =  viridisLite::plasma(6), 
                 type = 'scatter', mode = 'lines', 
                 legendgroup = ~StrainDescription
                 ) |>
  add_trace(x = ~hour, y = ~value, 
            color = ~StrainDescription, 
            type = 'scatter', mode = 'lines', 
            legendgroup = ~StrainDescription, linetype = ~StrainDescription,
            data = plt$plot_data)
}
curves_plot_Gompertz()
```

# Teaching a class

## Example: Let's shuffle a deck of cards

```{r}
#| echo: true
deck <- paste( c(2:10, 'Jack', 'Queen', 'King', 'Ace') |> rep(times=4), 'of',
               c('Spades','Diamonds','Clubs','Hearts') |> rep(each=13) )
# To draw a hand of 7 cards:
hand <- deck |> sample(7)

# Shuffling is taking a sample the same size (52) without replacement:
shuffled_deck <- deck |> sample(length(deck))

# To do a bootstrap sample just add: , TRUE
```

```{r}
data.frame(Deck = deck, Shuffled = shuffled_deck) |> plotly_table_MDAG()
```

## Explaining MCMC

This plot is the basis for my MCMC class:

```{r}
#| echo: true
#| eval: false
plotly::plot_ly(z=~volcano) |> plotly::add_surface()
```

```{r}
plot_ly(z=~volcano, width = fig_w*0.8, height = fig_h) |> add_surface()
```

## Spatial data class

```{r}
#| fig-asp: 0.6
library(leaflet)
leaflet() |>
  addTiles() |>
  addMarkers(lng = 27.828444, lat = -26.748972, popup = "SASA2025")
```

## Exploring code live

```{=html}
<iframe width="1000" height="600" src="https://seanvdm.co.za/files/presentations/Visualising%20densities/Visualising_densities.html#/title-slide" title="Exploring code live"></iframe>
```


## Text information

Perhaps we shall summarise the complete works of Shakespeare in a word cloud?

```{r}
#| eval: false
#| include: false
raw <- readLines("C:/temp/Complete Works Of William Shakespeare, The.txt")
cleantext <- function(mytext) { 
  mytext <- gsub("\\b\\d+\\b_", "", mytext)
}
clean_raw <- raw |> cleantext() |> paste(collapse=" ")
tidiedtext <- tokenizers::tokenize_words(clean_raw, simplify=TRUE)
freq <- table(tidiedtext) |> c()
freq_df <- data.frame(word = freq |> names(), freq = freq) |> 
  filter(freq > 9) |>
  filter(nchar(word) > 3) |> 
  filter(!(word |> str_detect("[0-9]")))
freq_df |> saveRDS("Shakespeare_words_above4.rds")
```

```{r}
#| fig-height: 6
#| fig-width: 8
freq_df <- readRDS("Shakespeare_words_above4.rds")
library(wordcloud2)
freq_df |> wordcloud2() |> frameWidget()
```


## Multivariate fun - Let's try a biplot

```{r SvdMbiplotPlotly, echo=FALSE}
biplot.plotly <- function(dataset, grouping_points=rep(1,nrow(dataset)), 
                          pointtext=rownames(dataset), expansion=1.16, 
                          width = "100%", height = "100%") {
  # Custom biplot function by Sean van der Merwe, University of the Free State
  # Takes already scaled matrix as input ideally
  PCA <- prcomp(dataset) # Do PCA
  lam <- PCA$sdev[1:2]*sqrt(nrow(dataset)) # Get scale parameter
  PoV <- (PCA$sdev^2)/sum(PCA$sdev^2)
  scores <- t(t(PCA$x[, 1:2])/lam)
  vars <- t(t(PCA$rotation[, 1:2])*lam)
  groupfac <- factor(grouping_points, levels = unique(grouping_points))
  colsvec <- as.numeric(groupfac)
  rangePoints <- apply(scores,2, function(x){max(abs(c(min(x),max(x))))})
  rangeArrows <- apply(vars,2, function(x){max(abs(c(min(x),max(x))))})
  vars <- t(t(vars)*rangePoints/rangeArrows)
  nArrows <- nrow(vars)
  nGroups <- nlevels(groupfac)
  colsarrows <- viridisLite::plasma(nArrows) |> unname()
  Finalcolpallette <- viridisLite::viridis(nGroups+2)[c(-1,-(nGroups+2))] |> unname()
  if (is.null(pointtext)) {pointtext=rep('', nrow(dataset))}
  plotdata <- data.frame(scores, Group=groupfac, Hover=pointtext, row.names = NULL)
  plotdata |> plot_ly(x=~PC1, y=~PC2, color = ~Group, text=pointtext, type='scatter', 
                      mode='markers', colors = Finalcolpallette,
                      width = width, height = height) |> 
  add_annotations(text=rownames(vars), ax=vars[,1]*expansion, ay=vars[,2]*expansion, 
                  x=vars[,1], y=vars[,2], xref='x', yref='y', axref='x', ayref='y', 
                  arrowcolor=colsarrows) |> 
  add_annotations(text='', x=vars[,1], y=vars[,2], ax=rep(0,nArrows), ay=rep(0,nArrows), 
                  xref='x', yref='y', axref='x', ayref='y', arrowcolor=colsarrows) |> 
  layout(xaxis=list(title=paste0('PC1 (',round(PoV[1]*100,1),'%)')), 
         yaxis = list(title=paste0('PC2 (',round(PoV[2]*100,1),'%)')))
}
set.seed(1234)
```

```{r}
#| echo: true
X <- rnorm(200) |> matrix(50)
colnames(X) <- paste('Var', 1:ncol(X))
Group <- sample(c('ðŸ¬', 'ðŸª'), nrow(X), TRUE)
biplot.plotly(X, grouping_points = Group, width = fig_w, height = fig_h) # Sean's function
```


# Conclusion

-   Interactive visualisations have many uses 
-   Presentations do not have to be static
    -   Interactivity is better than animation
-   **Have you thought about how such tools can help you convey information to your audiences?**

> This presentation was created using the Reveal.js format in [Quarto](https://quarto.org/), using the [RStudio IDE](https://posit.co/products/open-source/rstudio/). Background image created using image editor [GIMP](https://www.gimp.org/) by compositing images from CoPilot.

<!--
Notes on self-containing: https://mine-cetinkaya-rundel.github.io/quarto-tip-a-day/posts/09-self-contained/
-->

## Workshop resources

You likely received an email with these resources:


::: {.callout-note}
# All the workshop resources are on GitHub

Click this link: <https://github.com/MuViSU/SASA2025_MDAG>
:::





